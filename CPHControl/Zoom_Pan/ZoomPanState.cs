using OpenTK;
using System;
using System.Drawing;
using System.Windows.Forms;

namespace CPHControl
{
    public class ZoomPanState
    {
        #region Fields
        /// <summary>
        /// The owner pane of this
        /// </summary>
        private GraphPane _ownerPane;

        /// <summary>
        /// Bool to show if the pChart is panned automatically
        /// </summary>
        private bool _isAutoPan;
        /// <summary>
        /// Bool to show if the User is panning NOW
        /// </summary>
        private bool _panning;
        /// <summary>
        /// Bool to show if the last Operation was zooming
        /// </summary>
        private bool _zoomed = false;

        /// <summary>
        /// The f offset x, describing cummulated offset in x direction generated by zooming and panning
        /// </summary>
        private double _fOffsetX = 0.0;
        /// <summary>
        /// The f offset y, describing cummulated offset in y direction generated by zooming and panning
        /// </summary>
        private double _fOffsetY = 0.0;

        /// <summary>
        /// The x point where the pan is startet, gets resetset at each pan calculation
        /// </summary>
        private double _fStartPanX;
        /// <summary>
        /// The y point where the pan is startet, gets resetset at each pan calculation
        /// </summary>
        private double _fStartPanY;

        /// <summary>
        /// Timer that resets the Pan and zoom to Automatic mode.
        /// </summary>
        Timer _zoomPanTimer = new Timer();
        /// <summary>
        /// The zoom factor
        /// </summary>
        private double _zoomFac = 0.05;
        #endregion

        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="ZoomPanState"/> class.
        /// </summary>
        /// <param name="OwnerPane">The owner pane.</param>
        public ZoomPanState(ref GraphPane OwnerPane)
        {
            _ownerPane = OwnerPane;

            _isAutoPan = true;

            _zoomPanTimer.Tick += ZoomPanTimer_tick;
            _zoomPanTimer.Interval = 2000;

            _zoomPanTimer.Start();
        }
        #endregion

        #region Properties
        /// <summary>Gets or sets a value indicating whether this instance is automatic pan.</summary>
        /// <value>
        ///   <c>true</c> if this instance is automatic pan; otherwise, <c>false</c>.</value>
        public bool IsAutoPan
        {
            get { return _isAutoPan; }
            set { _isAutoPan = value; }
        }
        /// <summary>Gets or sets a value indicating whether this <a onclick="return false;" href="ZoomPanState" originaltag="see">ZoomPanState</a> is panning.</summary>
        /// <value>
        ///   <c>true</c> if panning; otherwise, <c>false</c>.</value>
        public bool Panning
        {
            get { return _panning; }
            set { _panning = value; }
        }
        #endregion

        #region Methods
        /// <summary>
        /// Pan is automatic, <see cref="XAxis"/> Scale gets modified in this function, if one graph line is outside the right pChart area
        /// </summary>
        /// <param name="xMax">The x maximum.</param>
        /// <param name="xAxis">The x axis.</param>
        public void AutoPan(double xMax, ref XAxis xAxis)
        {
            Scale xScale = xAxis.Scale;
            if (xScale.Max < xMax)
            {
                double dA = xAxis.Scale.Max - xAxis.Scale.Min;
                xScale.Max = xMax;
                xScale.Min = xMax - dA;
            }
        }

        /// <summary>
        /// Handles the tick event of the ZoomPanTimer control. Sets booleans to initialize auto panning
        /// and resetzs Zoom differences which result in combined zooming and panning actions.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        private void ZoomPanTimer_tick(object sender, EventArgs e)
        {
            ResetPan();
            _ownerPane.ResetZoomDiffs();

            _zoomed = false;
            _panning = false;
            _isAutoPan = true;
        }
        /// <summary>
        /// Resets the pan offsets
        /// </summary>
        private void ResetPan()
        {
            _fOffsetX = 0.0;
            _fOffsetY = 0.0;
        }
        /// <summary>
        /// Starts the panning operation. When the AutoPan is active,
        /// temporary max values are stored in all axes for panning and zooming references.
        /// This Function is only called when the OnMouseDown event happens.
        /// </summary>
        /// <param name="startPoint">The start point.</param>
        /// <param name="graphPane">The graph pane.</param>
        public void StartPan(PointF startPoint, GraphPane graphPane)
        {
            PointF transformedPoint = PointToViewport(startPoint, graphPane.PChart.Rect);
            _fStartPanX = transformedPoint.X;
            _fStartPanY = transformedPoint.Y;
            if (_isAutoPan)
            {
                double dA = graphPane.PXAxis.Scale.Max - graphPane.PXAxis.Scale.Min;
                graphPane.PXAxis.Scale.TmpMax = graphPane.PCurveList.GetXMax(graphPane);
                if (graphPane.PXAxis.Scale.TmpMax < graphPane.PXAxis.Scale.Max)
                    graphPane.PXAxis.Scale.TmpMax = graphPane.PXAxis.Scale.Max;

                foreach (YAxis axis in graphPane._yAxisList)
                {
                    axis.Scale.TmpMax = axis.Scale.Max;
                    axis.Scale.TmpMin = axis.Scale.Min;
                }
            }

            _panning = true;
            _isAutoPan = false;
        }

        /// <summary>
        /// Continues the panning operation after pan has started.
        /// </summary>
        /// <param name="point">The point.</param>
        /// <param name="graphPane">The graph pane.</param>
        public void Pan(PointF point, ref GraphPane graphPane)
        {
            PointF transformedPoint = PointToViewport(point, graphPane.PChart.Rect);
            _fOffsetX += transformedPoint.X - _fStartPanX;  //Offsets get updated by difference between this and last point
            _fOffsetY += transformedPoint.Y - _fStartPanY;

            double dA = graphPane.PXAxis.Scale.Max - graphPane.PXAxis.Scale.Min;  //Max and Min values of all Axes get updated
            graphPane.PXAxis.Scale.Max = graphPane.PXAxis.Scale.TmpMax - dA * 0.5 * _fOffsetX;
            if (_zoomed)
                graphPane.PXAxis.ZoomDiff = graphPane.PXAxis.ZoomCorrection - graphPane.PXAxis.Scale.Max;

            graphPane.PXAxis.Scale.Max += graphPane.PXAxis.ZoomDiff;
            graphPane.PXAxis.Scale.Min = graphPane.PXAxis.Scale.TmpMax - dA * 0.5 * _fOffsetX - dA + graphPane.PXAxis.ZoomDiff;

            foreach (YAxis axis in graphPane._yAxisList)
            {
                dA = axis.Scale.Max - axis.Scale.Min;
                axis.Scale.Max = axis.Scale.TmpMax - _fOffsetY * 0.5 * dA;

                if (_zoomed)
                    axis.ZoomDiff = axis.ZoomCorrection - axis.Scale.Max;

                axis.Scale.Max += axis.ZoomDiff;
                axis.Scale.Min = axis.Scale.TmpMin - _fOffsetY * 0.5 * dA + axis.ZoomDiff;
            }

            _fStartPanX = transformedPoint.X;   //the actual point becomes the next startpoint
            _fStartPanY = transformedPoint.Y;

            _zoomed = false;
            _zoomPanTimer.Stop();               //restart the timer that resets the autopan
            _zoomPanTimer.Start();
        }

        /// <summary>
        /// Zooms into the specified point.
        /// </summary>
        /// <param name="Point">The point.</param>
        /// <param name="pane">The pane.</param>
        /// <param name="delta">The delta, generated by the mouse event args, negative or positive depending on the mouse wheel direction.</param>
        public void Zoom(PointF Point, ref GraphPane pane, int delta)
        {
            double fZoomOffsetX = 0.0;
            double fZoomOffsetY = 0.0;

            double dA = pane.PXAxis.Scale.Max - pane.PXAxis.Scale.Min;
            PointF transformedPoint = PointToViewport(Point, pane.PChart.Rect);

            fZoomOffsetX = transformedPoint.X;  //save the offset from the middle of the specified rect
            fZoomOffsetY = transformedPoint.Y;
            if (_isAutoPan) //if zooming is the first zoom or pan action in autopan mode
            {               //we save the tempoprary Max values of the axes here.
                pane.PXAxis.Scale.TmpMax = pane.PCurveList.GetXMax(pane);
                if (pane.PXAxis.Scale.TmpMax < dA)
                    pane.PXAxis.Scale.TmpMax = dA;

                pane.PXAxis.Scale.TmpMin = pane.PXAxis.Scale.Min;
                foreach (YAxis axis in pane._yAxisList)
                {
                    axis.Scale.TmpMax = axis.Scale.Max;
                    axis.Scale.TmpMin = axis.Scale.Min;
                }
            }

            if (delta > 0)  //zooming in
            {
                pane.PXAxis.Scale.Max -= _zoomFac * dA * 0.5 * (1 - fZoomOffsetX);
                pane.PXAxis.Scale.TmpMax -= _zoomFac * dA * 0.5;
                pane.PXAxis.Scale.Min += _zoomFac * dA * 0.5 * (1 + fZoomOffsetX);
                pane.PXAxis.Scale.TmpMin += _zoomFac * dA * 0.5;
                foreach (YAxis axis in pane._yAxisList)
                {
                    dA = axis.Scale.Max - axis.Scale.Min;
                    axis.Scale.Max -= _zoomFac * dA * 0.5 * (1 - fZoomOffsetY);
                    axis.Scale.TmpMax -= _zoomFac * dA * 0.5;
                    axis.Scale.Min += _zoomFac * dA * 0.5 * (1 + fZoomOffsetY);
                    axis.Scale.TmpMin += _zoomFac * dA * 0.5;
                }

                _fOffsetX -= _zoomFac * fZoomOffsetX;
                _fOffsetX *= 1 + _zoomFac;
                _fOffsetY -= _zoomFac * fZoomOffsetY;
                _fOffsetY *= 1 + _zoomFac;

            }
            else            //zooming out
            {
                pane.PXAxis.Scale.Max += _zoomFac * dA * 0.5 * (1 - fZoomOffsetX);
                pane.PXAxis.Scale.TmpMax += _zoomFac * dA * 0.5;
                pane.PXAxis.Scale.Min -= _zoomFac * dA * 0.5 * (1 + fZoomOffsetX);
                pane.PXAxis.Scale.TmpMin -= _zoomFac * dA * 0.5;
                foreach (YAxis axis in pane._yAxisList)
                {
                    dA = axis.Scale.Max - axis.Scale.Min;
                    axis.Scale.Max += _zoomFac * dA * 0.5 * (1 - fZoomOffsetY);
                    axis.Scale.TmpMax += _zoomFac * dA * 0.5;
                    axis.Scale.Min -= _zoomFac * dA * 0.5 * (1 + fZoomOffsetY);
                    axis.Scale.TmpMin -= _zoomFac * dA * 0.5;
                }

                _fOffsetX += _zoomFac * fZoomOffsetX;
                _fOffsetX *= 1 - _zoomFac;
                _fOffsetY += _zoomFac * fZoomOffsetY;
                _fOffsetY *= 1 - _zoomFac;
            }
            // The zoom correction is for a slight offset happening when panning after zooming
            pane.PXAxis.ZoomCorrection = pane.PXAxis.Scale.Max;
            foreach (YAxis axis in pane._yAxisList)
            {
                axis.ZoomCorrection = axis.Scale.Max;
            }

            _isAutoPan = false;
            _zoomed = true;
            _zoomPanTimer.Stop();
            _zoomPanTimer.Start();
        }

        /// <summary>
        /// Translate a point to the x/y-coordinate system of the viewport
        /// </summary>
        /// <param name="point">The point.</param>
        /// <param name="rect">The rect.</param>
        /// <returns>Gets the transformed point in the coordinatesystem of the viewport which ranges -1...1 in x and y</returns>
        private PointF PointToViewport(PointF point, GLRectangleF rect)
        {
            PointF ViewportPoint = new PointF
            {
                X = 2 * (point.X - rect.X) / rect.Width - 1,
                Y = 2 * (point.Y - rect.Y) / rect.Height - 1
            };

            return ViewportPoint;
        }
        #endregion
    }
}
